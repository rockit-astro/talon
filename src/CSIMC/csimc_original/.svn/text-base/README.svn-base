Whereas
    FLASH is mapped to CSP0 at 8000..ffff;
    text and const data will not all fit in FLASH;
    even if it did still need a way to init data in SRAM;
Therefore
    must use higher FLASH PPAGEs to hold extra pages;
    extra pages get copied to correct place by boot program in EEPROM;
    also store FLEX code and a loader program in a FLASH pages;

Application is built as one program, main.s19, then

    portion 8000..bfff is stored in FLASH PPAGE 0  (same as real 8000..bfff)
    portion 0400..3fff is stored in FLASH PPAGE 1
    portion 4000..6fff is stored in FLASH PPAGE 2
    portion c000..ffff is stored in FLASH PPAGE 1f (same as real c000..ffff)

FLEX code:

    FLEX code is stored in FLASH PPAGE 3. Resides in flex_data.s19, mapped
    from 8004 up to as high as bfff. At 8000 is the number of bytes in the
    FLEX program. At 8002 is the 16-bit sum of the FLEX program.

Stand-alone loader is in FLASH PPAGE 4. See BOOT packet section.

Building a new board:

    connect BDM pod to /dev/ttyS0 on host and POD connector on CSIMC
    put shunt in JP5/1-2 to enable self-test
    "make new" will load all code, and start self-test

Power-on sequence, performed by the separate program boot.c:

    EEPROM is in map at f000..ffff
    RESET vectors to idle loop, waiting for COP (default is in 1 second)
    COP vectors to _start
    setup HC12 regs
    init stack to top of internal SRAM (so as to be hidden from selftest)
    init boot's bss
    load FLEX program from PPAGE 3
    if FLEX program looks invalid, fails or self-test pin is installed
	run self-test forever
    load main program into SRAM from pages of FLASH:
	set PPAGE = 1, copy 8400..bfff to 0400..3fff
	set PPAGE = 2, copy 8000..afff to 4000..6fff
    set PPAGE = 0 to instate main app in 8000..bfff
    jump to main app, via 8000
	remove EEPROM from map to expose main app's f000..ffff
	init stack to just below _text_start
	init main's bss
	init Heap from _bss_end to _text_start - NCSTACK
	proceed with main app

BOOT packet arrives:

    main challange is to provide a way to write FLASH and EEPROM, which can
        only be done by a program running in RAM.
    main application is running.. sees BOOT packet:
    pushes address of BOOT packet then does a CALL to 8c00 in PPAGE 4
    here resides a small loop and a stand-alone boot loader linked to operate
	from 0c00. This addr is chosen to be in RAM but stay beneath main's
	rpkt (containing the first BOOT packet) and stack and to avoid
	boot.c's data which is all within 0800..0bff to hide during memory
	self-test.
    the loop copies the SA loader to 0c00 and jumps there to go
    the SA loader handles all additional BOOT packets completely on its own
        from both the 232 and 485 LAN
    the SA loader can write any type of memory.
    when SA loader sees a BOOT packet with an EXEC type, it lets COP time out
	which reboots and starts the new code.
    host never knows a different loader handles the latter part of a load.
    the boot traffic consists of mainpg*.s19, boot.s19 and flex_prog.s19,
	each preceded by writes to PPAGE to establish the correct FLASH page.
	these are packacked into main.cmf using s19tocmf.

FLASH summary:

    PPAGE  0: main program, mainpg00.s19, ends up at 8000..bfff
    PPAGE  1: main program, mainpg01.s19, ends up at 0400..3fff
    PPAGE  2: main program, mainpg02.s19, ends up at 4000..6fff
    PPAGE 1f: main program, mainpg1f.s19, ends up at c000..ffff
    PPAGE  3: FLEX program, flex_prog.s19
    PPAGE  4: stand-alone loader program, saloader.s19
    PPAGE  5..1e: unused

Communications:

    See description of the token-ring nature of the protocol in the Manual.
    This discussion is geared to the code, not really the architecture.

    Incoming char interrupt:
	chars arrive and are put into rpkt
	if see good normal packet set rpktrdy
	if see ack for xpkt set xacked
	if see our token and wanttoken is set then set ourtoken,
	    else start xmtr working to send BROKTOK
	chars arriving while rpktrdy is set are dropped
    Outgoing char interrupt:
	if more to send from xpkt then send next char
	else if was sending ack packet set acksent

    Scheduler:
	if rpktrdy is set
	    dispatch depending on type of packet
		CMD copies rpkt to pti.sin, call sendAck
		SETVAR extracts ref and value and sets variable, call sendAck
		GETVAR extracts ref, call sendAckVar(value)
	    clear rpktrdy
    getchar():
	reads from pti.sin, or blocks by calling scheduler while empty
    putchar():
	put onto pti.sout
	when fills or see \n
	    wait 4 xpkt
	    fill xpkt from pti.sout, set type to CMD
	    send xpkt
	    give up token
    to set a variable on another node:
	wait 4 xpkt
	fill xpkt with variable reference and value, set type to SETVAR
	send xpkt
	give up token
    to get a variable from another node:
	wait 4 xpkt
	fill xpkt with variable reference, set type to GETVAR
	send xpkt
	pull value from rpkt packet (stable because we have token)
	give up token
    send xpkt:
	set wanttoken
	loop calling scheduler until see ourtoken
	start xmtr working to send xpkt
	loop calling scheduler until see xacked
	clear wanttoken
	clear xpktbsy
    give up token
	clear ourtoken
	start xmtr working to send BROKTOK
    wait 4 xpkt:
	loop calling scheduler until see xpktbsy is clear, then set
    sendAck
	build an ack packet for rpkt
	start xmtr working to send ack packet
    sendGETAck
	build an ack packet for rpkt with value in data
	start xmtr working to send ack packet

Technical note:

    A separate buffer exists for sending ack packets than other packets. The
    issue with using xpkt for ACKs is shown as follows:

	    Node A                            Node B
	(1)	send	----- Routine 1 ------- >
	(2)	missed  < --- ACK -------------
	(3)	ignored < --- Routine 2 -------
	(4)	resend  ----- Routine 1 ------- >
	(5)	ok      < --- ACK -------------

	Suppose Node A misses an ACK then Node B sends something new (since
	it thought it was finished). In order for Node B to resend ACK in xpkt
	at (5), it must discard the info it filled it with at (3). Having a
	separate buffer just for sending ACKs avoids this application-level
	refilling of xpkt for retransmissions. Note that xackpkt can be fixed
	to length PB_HSZ so it uses very little extra memory. This also
	allows a node to receive and respond to packets while it is trying
	to send, enhancing service to possibly-urgent packets.

	Can't really do the same for rpkt since we don't know whether a
	packet is ACK until already begun collecting chars.

To find PC of thread:

    run stats() to get thread id.
    convert to DPAGE (ala setPTI).
    use bdm12 to stop, set DPAGE, dump pti, find ctxt.
    thread's frame pointer, x, is at ctxt[2].
    thread's PC is at x[1], use main.mp and main.lst to interpret
    previous frame pointer is at x[0].. walk back as required

to help find funtions that use the most stack:

    awk -Fleas 'NF>1{print $2, $0;}' < main.lst | sort -n | head



memory map:

0000 01ff 512	HC12 registers. ports assigned as follows:
		PA0-7		bus addressing
		PB0-7		bus addressing
		PC0-7		bus data
		PD0-7		bus data
		PE0-3,5-7	bus control
		PE4		0->1 to latch both words of mot/enc counters
		PF0		CS0:	FLEX chip select while running app
		PF1		In:	FLASH RYnBY
		PF2		Out:	manual FLEX chip sel during programmed
		PF3		Out:	RS485 PTT: 1 to talk, 0 to listen
		PF4		CSD: Static RAM chip select, 0000..7fff
		PF5		CSP0: FLASH chip select, 8000..ffff
 		PF6		Output: motor direction; count increases when 1
		PF7		does not exist!
		PG0-7		bus addressing
		PH0-7		misc output lines
		PJ0-7		misc input lines
		PS0-1		serial port 0:RS485 LAN 1=Tx 0=Rx
		PS2-3		serial port 1:RS232 port 3=Tx 2=Rx
		PS4		FLEX: CONF_DONE
		PS5		FLEX: DEV_OE
		PS6		FLEX: nCONFIG
		PS7		FLEX: RDYnBSY
		PT0-4		5-bit board select DIP, Closed=1
		PT5		Self-test otherwise unassigned; on Expansion
		PT6-7		unassigned, on Expansion header
		PAD0-7	A/D, all routed to A/D header
0200 037f 384	cs0 	FLEX chip select while running. Programmed as follows:
		0200 .. 0201	motor speed NCO high word, R/W
		0202 .. 0203	" low word, latches both R/W
				F in Hz = N(16x10^6)/2^32 ~ .003725290N, or
				N ~ 268.435456F
		0204 .. 0205	motor counter high word, R/O
		0206 .. 0207	" low word, R/O
		0208 .. 0209	encoder counter high word, R/O
		020a .. 020b	" low word, R/O
		020c .. 020d	1 resets and holds motor counter at 0, R/W
		020e .. 020f	1 resets and holds encoder counter at 0, R/W
		0210 .. 0211	1 indicates encoder error == EncoderError, R/W
		0212 .. 023d	undefined 
		023e .. 023f	program version number, R/O
		0240 .. 037f	undefined
0380 03ff 128	cs2 FLEX chip select for programming
		0380 .. 03ff	write any odd address with program bytes, W/O
0400 07ff  1k	external SRAM, part of DPAGE 0x10, requires CSD
0800 0bff  1k	internal SRAM (higher priority than SRAM)
0c00 0fff  1k	external SRAM, part of DPAGE 0x10, requires CSD
1000 1fff  4k	external SRAM, same as DPAGE 0x11, requires CSD
2000 2fff  4k	external SRAM, same as DPAGE 0x12, requires CSD
3000 3fff  4k	external SRAM, same as DPAGE 0x13, requires CSD
4000 4fff  4k	external SRAM, same as DPAGE 0x14, requires CSD
5000 5fff  4k	external SRAM, same as DPAGE 0x15, requires CSD
6000 6fff  4k	external SRAM, same as DPAGE 0x16, requires CSD
7000 7fff  4k	external SRAM, controlled by DPAGE, 0..1f, requires CSD
8000 b777 16k	external FLASH, controlled by PPAGE, 0..1f, requires CSP0
c000 efff 15k	external FLASH, same as PPAGE 1f, requires CSP0
f000 ffff  1k	internal EEPROM, or overlayed with FLASH PPAGE 1f
ff00 ff7f 128	BDM sometimes
ff80 ffff 128	interrupt vectors

# For RCS Only -- Do Not Edit
# @(#) $RCSfile: README,v $ $Date: 2001/04/19 21:11:57 $ $Revision: 1.1.1.1 $ $Name:  $
