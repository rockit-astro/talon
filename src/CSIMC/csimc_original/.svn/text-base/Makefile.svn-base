# Makefile for CSIMC Rev C
# there are really three separate programs:
#  boot: goes into EEPROM on a new board. does self-tests and can boot main.
#  main: the real application, goes into FLASH
#  saloader: stand-alone loader which can reload EEPROM and FLASH from LAN

# location of executables, libs and include files and misc compiler flags
DEV_BASE = $(HOME)/telescope
ICC_BASE = $(DEV_BASE)/CSIMC/icc
ICC_LIB = $(ICC_BASE)/lib
ICC_BIN = $(ICC_BASE)/bin
ICC_INCLUDE = $(ICC_BASE)/include
CC = $(ICC_BIN)/icc12
CLDFLAGS = -R
DEBUGF = -A -w
#DEBUGF = -A -w -l -m
CFLAGS = $(CLDFLAGS) $(DEBUGF) -I$(ICC_INCLUDE) -I$(DEV_BASE)/libmisc
YFLAGS = -d -v -b gram
LIBS = -lc12

# how to run bdm, the pod interface program for debugging
BDM12 = bdm12 -c 100000 -t /dev/ttyS0

# boot program linker setup.
# text must all fit into EEPROM, f000..ffff.
# put data in internal SRAM to hide from external SRAM self-test
BOOT_LINKER_OPTS = \
	-m \
	-ddstart=0x0800 \
	-btext:0xf000.0xff00 \
	-bdata:dstart \
	-bidata:dstart

BLDFLAGS = $(CLDFLAGS) $(DEBUGF) $(BOOT_LINKER_OPTS) -L$(ICC_LIB) -ustart.o

# files comprising the boot program in EEPROM
BOOT_OBJS = 		\
	boot.o		\
	motenc.o	\
	utils.o

BOOT_SRCS =  $(BOOT_OBJS:.o=.c)

# main application linker setup.
# start text as high as possible and yet so it fits under vectors map at ff00.
# leave hole 0x7000..0x7fff for per-thread info via DPAGE
# stack starts below text and grows down wards.
# reserve 8000 to hold addr of main for use by boot
MAIN_LINKER_OPTS = \
	-m \
	-ddstart=0x0400 \
	-btext:0x67c0.0x6fff:0x8002.0xff00 \
	-bdata:dstart \
	-bidata:dstart

MLDFLAGS = $(CLDFLAGS) $(DEBUGF) $(MAIN_LINKER_OPTS) -L$(ICC_LIB) -ustart.o

# files comprising the main application
MAIN_OBJS = 		\
	cq.o		\
	exec.o		\
	funcs.o		\
	gram.tab.o	\
	intr.o		\
	lan.o		\
	lex.o		\
	main.o		\
	motenc.o	\
	motion.o	\
	rs232.o		\
	thread.o	\
	ufuncs.o	\
	utils.o		\
	var.o

MAIN_SRCS =  $(MAIN_OBJS:.o=.c)

# default target just lists some useful targets.
help:
	@echo Choose a target:
	@echo "  clobber:    " remove all temp files but enough for loadall
	@echo "  clean:      " remove everything that can not be recreated
	@echo "  eraseflash: " erase all of FLASH
	@echo "  files:      " build all files but do not touch the CSIMC
	@echo "  boot.s19:   " build the EEPROM boot code
	@echo "  main.s19:   " build the main application
	@echo "  loadselft:  " load a new board with EEPROM and FLEX, then start
	@echo "  loadrest:   " if loadselft works, this loads the rest
	@echo "  loadall:    " loadselft + loadrest
	@echo "  loadee:     " load EEPROM, then start
	@echo "  connect:    " connect to a CSIMC running the main app
	@echo "  connectboot:" connect to a CSIMC running the boot

# build all necessary files but don't touch the board
files:	mainpg00.s19 flex_prog.s19 boot.s19 saloader.s19 main.cmf

# load a brand new board with everything, then start
loadall: files loadee eraseflash loadflex loadmain loadsaloader
	echo 'q' | $(BDM12)
	echo 

# load a brand new board with the basic boot and flex code, then start
loadselft: loadee eraseflash loadflex
	echo 'q' | $(BDM12)
	echo 

# loadall = loadselft + loadrest
loadrest: loadmain loadsaloader
	echo 'q' | $(BDM12)
	echo 

# load the EEPROM boot code, then start
loadee: init.bdm boot.s19
	echo 'l init.bdm; b' | $(BDM12)
	@echo ""; echo "****** loading boot code into EEPROM"
	echo 'Pv boot.s19' | $(BDM12)
	echo 'q' | $(BDM12)
	echo 

# erase **all** of FLASH
eraseflash: init.bdm
	echo 'l init.bdm; b' | $(BDM12)
	@ echo "****** erasing FLASH"
	echo 'w ppage 3; A! 8000' | $(BDM12)

# load the FLEX program into FLASH
# N.B. this does not pre-erase
loadflex: init.bdm flex_prog.s19
	echo 'l init.bdm; b' | $(BDM12)
	@echo ""; echo "****** loading FLEX code into FLASH PAGE 3"
	echo 'w PPAGE  3; Qv flex_prog.s19' | $(BDM12)

# load the main application program info FLASH
# N.B. this does not pre-erase
loadmain: init.bdm mainpg00.s19
	echo 'l init.bdm' | $(BDM12)
	@echo ""; echo "****** loading main code into FLASH PAGE 0"
	echo 'w PPAGE  0; Qv mainpg00.s19' | $(BDM12)
	@echo ""; echo "****** loading main code into FLASH PAGE 1"
	echo 'w PPAGE  1; Qv mainpg01.s19' | $(BDM12)
	@echo ""; echo "****** loading main code into FLASH PAGE 2"
	echo 'w PPAGE  2; Qv mainpg02.s19' | $(BDM12)
	@echo ""; echo "****** loading main code into FLASH PAGE 1f"
	echo 'w PPAGE 1f; Qv mainpg1f.s19' | $(BDM12)

# break up the main program into the pieces destined for FLASH pages
mainpg00.s19: main.s19 remap.sed
	grep -i '^S...[89ab]' main.s19 | ./remap.sed > mainpg00.s19
	grep -i '^S...[0123]' main.s19 | ./remap.sed > mainpg01.s19
	grep -i '^S...[4567]' main.s19 | ./remap.sed > mainpg02.s19
	grep -i '^S...[cdef]' main.s19 | ./remap.sed > mainpg1f.s19

# mung the raw-binary-format FLEX program into what we store in FLASH
flex_prog.s19: mkflex_prog motionio.rbf
	./mkflex_prog < motionio.rbf > flex_prog.s19

# compile and link the main program
# N.B. link start.o first then end.o last to properaly set up the sections
main.s19: $(MAIN_OBJS) start.o end.o
	$(CC) $(MLDFLAGS) -o $@ start.o $(MAIN_OBJS) $(LIBS) end.o
	@grep bytes main.mp | head -n 3
	@echo -n '                                                  '
	@grep bytes main.mp | head -n 3 | awk '{t+=$$5}END{print t}'

gram.tab.c: gram.y yymung
	$(YACC) $(YFLAGS) $<
	@./yymung < gram.tab.c > x.x.c
	@mv x.x.c gram.tab.c

lex.yy.o: gram.l
	$(LEX) $(LFLAGS) $<
	$(CC) $(CFLAGS) -c lex.yy.c -o $@

# compile and link the boot program
# N.B. link start.o first then end.o last to properaly set up the sections
boot.s19: start.o $(BOOT_OBJS) end.o
	$(CC) $(BLDFLAGS) -o $@ start.o $(BOOT_OBJS) $(LIBS) end.o
	@grep bytes boot.mp | head -n 3
	@echo -n '                                                   '
	@grep bytes boot.mp | head -n 3 | awk '{t+=$$5}END{print t}'

# use BDM pod to connect to a CSIMC running the main program
connect:
	$(BDM12) -l main.lst -m main.mp

# use BDM pod to connect to a CSIMC running the boot program
connectboot:
	$(BDM12) -l boot.lst -m boot.mp

# make the firmware load image
main.cmf: s19tocmf boot.s19 mainpg00.s19 flex_prog.s19 saloader.s19
	@awk '/define.VERSION/ {print $$3;}' ver.h > $@
	./s19tocmf -e boot.s19 >> $@
	./s19tocmf -f 0x00 mainpg00.s19 >> $@
	./s19tocmf -f 0x01 mainpg01.s19 >> $@
	./s19tocmf -f 0x02 mainpg02.s19 >> $@
	./s19tocmf -f 0x1f mainpg1f.s19 >> $@
	./s19tocmf -f 0x03 flex_prog.s19 >> $@
	./s19tocmf -f 0x04 saloader.s19 >> $@
	./s19tocmf -x 0x00 >> $@

# capture VERSION
var.o:	ver.h

# stand-alone loader program linker setup.
SAL_LINKER_OPTS = -m
SLDFLAGS = $(CLDFLAGS) $(DEBUGF) $(SAL_LINKER_OPTS) -L$(ICC_LIB) -ustart.o
SAL_OBJS =		\
	saloader.o

# compile and link the standalone loader program
# relocate .s19 image to FLAHS PPAGE
saloader.s19: $(SAL_OBJS) start.o end.o
	$(CC) $(SLDFLAGS) -o $@ start.o $(SAL_OBJS) end.o
	./remap.sed < $@ > x.s19
	mv x.s19 $@

# load the stand-alone loader program into FLASH PPAGE 4
# N.B. this does not pre-erase
loadsaloader: init.bdm saloader.s19
	echo 'l init.bdm; b' | $(BDM12)
	@echo ""; echo "****** loading saloader code into FLASH PAGE 4"
	echo 'w PPAGE  4; Qv saloader.s19' | $(BDM12)

# compile and link the tool that converts .s19 files to .cmf files
s19tocmf: s19tocmf.o
	gcc -Wall -O -o s19tocmf s19tocmf.o

s19tocmf.o: s19tocmf.c
	gcc -I$(DEV_BASE)/libmisc -O -c s19tocmf.c

# build files during OCAAS build
pass3x: files

# remove everything but leave enough that loadall will without a icc12 compiler.
clobber:
	@ touch x.lis; rm *.lis
	@ touch x.lst; rm *.lst
	@ touch x.mp; rm *.mp
	@ touch x.map; rm *.map
	@ touch x.dbg; rm *.dbg
	@ touch x.cmd; rm *.cmd
	@ touch x.output; rm *.output
	@ touch x.s; rm *.s
	@ rm -f lex.yy.c
	@ rm -f gram
	@ rm -f core

# remove all derived files
clean: clobber
	@ touch x.o; rm *.o
	@ touch x.s19; rm *.s19
	@ touch x.cmf; rm *.cmf
	@ rm -f gram.tab.c gram.tab.h
	@ rm -f s19tocmf

# For RCS Only -- Do Not Edit
# @(#) $RCSfile: Makefile,v $ $Date: 2001/04/19 21:11:57 $ $Revision: 1.1.1.1 $ $Name:  $
