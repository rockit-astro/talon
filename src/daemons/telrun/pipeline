#!/usr/bin/perl

# This Perl script is run by the pvcam script after acquisition
# and cut up of image.  
#
# usage:
#    pipeline fullpath-basename-and-sequence
#
#-----
# Configurable options:
#
# This post-processing pipeline script may be expanded to suit as needed.
# The format should be reasonably understandable and simple to expand upon.
# This section gives some simple configuration-style control of
# what is anticipated as common options
#
# ++++
# Shared configuration file (with pvcam and calimagePV)

$TELHOME = $ENV{TELHOME};
do "$TELHOME/archive/config/pvcam.cfg";

# options are controlled by pipeline.cfg file, and pvoptions (1/2 M) (2002-12-13)
do "$TELHOME/archive/config/pipeline.cfg";

# ++++
# Trash bin file
$trashBin = "$TELHOME/archive/trash";

# Log file info
$elog = "$TELHOME/archive/logs/pipeline.log";

# set $traceon to 1 if want trace info in the log file
$traceon = 1;

# ==================================

# sync output
$| = 1;

# Sanity check: Make sure we have a filename and it exists
&errlog ("Wrong number of arguments: @ARGV\n") if @ARGV != 1;
$base = $ARGV[0];

&trace("\n===============\nprocessing $base");

# Do each section, saving the center section for last
# Only process the center section if either $preserveCenter or $resultToCamera are set
@sects = split /,/, $sectionNames;
$center = $base.(@sects[0]).".fts";
while($sect = pop(@sects))
{		
	$file = $base.$sect.".fts";
	
	if($file eq $center) {
		unless($preserveCenter || $resultToCamera)
		{
			next;
		}
	}		

	&trace("section $sect");
		
	if($doCorrections) {
		$corrDir = "$TELHOME/archive/calib";
		unless($file eq $center) {
			$corrDir .= "/".$sect;
		}
		$rt = `calimage -d $corrDir -C $file`;
		&trace("$rt : calimage -d $corrDir -C $file");
	}
	
	if($doWCS) {
		$rt = `wcs -wu $wcsRadius $file`;
		&trace("$rt : wcs -wu $wcsRadius $file");
	}
	
	if($doFWHM) {
		$rt = `fwhm -w $file`;
		&trace("$rt : fwhm -w $file");
	}
	
	# any further processing on uncompressed file should be inserted here
	
	# Never compress the center return file
	if($file ne $center)
	{			
		if($imageCompression) {
			# fcompress will remove the fts file and create an fth file
			$cmp_file = $base.$sect.".fth";
		
			# don't do this if the compressed file exists already
			unless(-e $cmp_file) {
				$rt = `fcompress -s $imageCompression -r $file`;
				&trace("$rt : fcompress -s $imageCompression -r $file");
						
				# from now on, any further processing must be on the .fth file,
				# since the .fts file is gone
				if(-e $cmp_file) {
					$file = $cmp_file;
				}
			}
			
			# any further processing for only compressed files should go here
		}
		
		# any processing on a file that may be compressed or not should go here
	}
			
}

# now what to do about the center section...

# first, empty any old trash
&emptyTrash();

# send result of center section processing to camera
if($resultToCamera) {
	
	$camfifo = "$TELHOME/comm/CameraFilename";
	
	&trace("returning $center to $camfifo");
	
	if(-p $camfifo) {
	
		# we spawn a process to output the filename to the fifo
		# but it might hang if the camera that owns it is gone, so we have
		# to wait a bit then look to see if it's still running
		# and if so, kill it.
	
		system("echo $center >> $camfifo &");
		sleep 5;
		open P, "ps T |" or errlog("can't fork for ps: $!\n");
		while(<P>) {
			chomp();
			 # &trace("ps: $_");
			if(m`sh -c echo`) {
				$pid = substr($_,0,5);
				&trace("Found pid $pid, killing...");
				`kill $pid`;
				last;
			}
		}
		close P;						
	}
	else
	{
		&trace("FIFO $camfifo not available");
	}
}
	
# we can delete the center section if we don't want it
unless($preserveCenter) {

	&throwAway($center);
}

exit(0);

# =====================

# save file name to a trash bin where it will be deleted on subsequent passes
sub throwAway
{
	$file = $_[0];
		
	open F, ">>$trashBin" or print EL " Can not open $trashBin: $!\n";
	print F $file;
	print F " ";	
    close F;

	&trace("$file scheduled for deletion");		
}	    	
		

# delete files named in trash bin
sub emptyTrash
{
	&trace("Emptying trash...");
	open F, "<$trashBin" or return;
	while($file = <F>) {
		chomp($file);
		$rt = `rm -f $file`;
		&trace("$rt : removing $file");
	}
	close F;
	unlink($trashBin);
}

# =====================

# append $_[0] to STDOUT and timestamp + $_[0] to $elog and exit
sub errlog
{
	print " $_[0]";
	open EL, ">>$elog";
	$ts = `jd -t`;
	print EL "$ts: $_[0]\n";
	close EL;
	exit 1;
}

# if $trace: append $_[0] to $elog
sub trace
{
	return unless ($traceon);
	open TL, ">>$elog";
	$ts = `jd -t`;
	print TL "$ts: $_[0]\n";
	close TL;
}
